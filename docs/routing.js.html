<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>routing.js - Postman Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-buffers.html">buffers</a><ul class='methods'><li data-type='method'><a href="module-buffers.html#.gen">gen</a></li><li data-type='method'><a href="module-buffers.html#.sample">sample</a></li><li data-type='method'><a href="module-buffers.html#.source">source</a></li><li data-type='method'><a href="module-buffers.html#.white">white</a></li></ul></li><li><a href="module-context.html">context</a><ul class='methods'><li data-type='method'><a href="module-context.html#.after">after</a></li><li data-type='method'><a href="module-context.html#.context">context</a></li><li data-type='method'><a href="module-context.html#.dest">dest</a></li><li data-type='method'><a href="module-context.html#.now">now</a></li><li data-type='method'><a href="module-context.html#.samplingRate">samplingRate</a></li><li data-type='method'><a href="module-context.html#.timeToSamples">timeToSamples</a></li><li data-type='method'><a href="module-context.html#.when">when</a></li></ul></li><li><a href="module-effects.html">effects</a><ul class='methods'><li data-type='method'><a href="module-effects.html#.delay">delay</a></li><li data-type='method'><a href="module-effects.html#.dly">dly</a></li><li data-type='method'><a href="module-effects.html#.feedback">feedback</a></li><li data-type='method'><a href="module-effects.html#.mix">mix</a></li><li data-type='method'><a href="module-effects.html#.tremolo">tremolo</a></li></ul></li><li><a href="module-envelopes.html">envelopes</a><ul class='methods'><li data-type='method'><a href="module-envelopes.html#.adsr">adsr</a></li><li data-type='method'><a href="module-envelopes.html#.freqEnv">freqEnv</a></li><li data-type='method'><a href="module-envelopes.html#.perc">perc</a></li></ul></li><li><a href="module-filters.html">filters</a><ul class='methods'><li data-type='method'><a href="module-filters.html#.bandpass">bandpass</a></li><li data-type='method'><a href="module-filters.html#.filter">filter</a></li><li data-type='method'><a href="module-filters.html#.hipass">hipass</a></li><li data-type='method'><a href="module-filters.html#.lowpass">lowpass</a></li></ul></li><li><a href="module-instruments.html">instruments</a><ul class='methods'><li data-type='method'><a href="module-instruments.html#.inst">inst</a></li></ul></li><li><a href="module-load.html">load</a><ul class='methods'><li data-type='method'><a href="module-load.html#.decodeAudio">decodeAudio</a></li><li data-type='method'><a href="module-load.html#.fetch">fetch</a></li><li data-type='method'><a href="module-load.html#.load">load</a></li></ul></li><li><a href="module-oscillators.html">oscillators</a><ul class='methods'><li data-type='method'><a href="module-oscillators.html#.lfo">lfo</a></li><li data-type='method'><a href="module-oscillators.html#.osc">osc</a></li><li data-type='method'><a href="module-oscillators.html#.saw">saw</a></li><li data-type='method'><a href="module-oscillators.html#.sine">sine</a></li><li data-type='method'><a href="module-oscillators.html#.square">square</a></li><li data-type='method'><a href="module-oscillators.html#.triangle">triangle</a></li></ul></li><li><a href="module-routing.html">routing</a><ul class='methods'><li data-type='method'><a href="module-routing.html#.add">add</a></li><li data-type='method'><a href="module-routing.html#.conn">conn</a></li></ul></li><li><a href="module-signals.html">signals</a><ul class='methods'><li data-type='method'><a href="module-signals.html#.bypass">bypass</a></li><li data-type='method'><a href="module-signals.html#.constant">constant</a></li><li data-type='method'><a href="module-signals.html#.gain">gain</a></li><li data-type='method'><a href="module-signals.html#.mult">mult</a></li><li data-type='method'><a href="module-signals.html#.scale">scale</a></li><li data-type='method'><a href="module-signals.html#.signal">signal</a></li></ul></li><li><a href="module-synths.html">synths</a><ul class='methods'><li data-type='method'><a href="module-synths.html#.additive">additive</a></li><li data-type='method'><a href="module-synths.html#.subtractive">subtractive</a></li><li data-type='method'><a href="module-synths.html#.withOptions">withOptions</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#dB">dB</a></li><li><a href="global.html#gainToDb">gainToDb</a></li><li><a href="global.html#note">note</a></li><li><a href="global.html#tempo">tempo</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">routing.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { when } from './context'
import { slice, isArray } from './utils'

/**
 * This module provides two ways to route nodes:
 *
 * - In series: A -> B -> C -> D, using the `connect` function
 * - In parallel: in -> [A, B, C] -> out, using the `add` function
 * @module routing
 */

/**
 * Connect nodes in series: A -> B -> C -> D.
 * @param {Array&lt;AudioNode>} nodes - the list of nodes to be connected
 * @return {AudioNode} the resulting audio node
 */
export function conn (nodes) {
  nodes = isArray(nodes) ? nodes : slice.call(arguments)
  if (!nodes.length) return null
  else if (nodes.length === 1) return nodes[0]

  var node = nodes[0]
  if (!node.duration) node.duration = 0
  var last = nodes.reduce(function (src, dest) {
    src.connect(dest)
    node.duration = Math.max(node.duration, dest.duration || 0)
    return dest
  })
  setOutput(node, last)
  var startables = startable(nodes.slice(1))
  if (startables) {
    var _start = node.start
    node.start = function (time) {
      if (_start) _start.call(node, time)
      startables.forEach(function (node) { node.start(time) })
      if (node.duration) node.stop(time + node.duration)
    }
    var _stop = node.stop
    node.stop = function (time) {
      var t = 0
      startables.reverse()
      startables.forEach(function (node) {
        t = t || when(time, null, node.context)
        node.stop(t)
        t += node.release || 0
      })
      if (_stop) _stop.call(node, t)
    }
  }
  return node
}

// TODO: A RESOLVER: add debe tener onended cuando acaben todos sus nodos
/**
 * Connect nodes in parallel in order to add signals. This is one of the
 * routing functions (the other is `connect`).
 * @param {...AudioNode} nodes - the nodes to be connected
 * @return {AudioNode} the resulting audio node
 * @example
 * add(sine(400), sine(401)).start()
 */
export function add (nodes) {
  nodes = isArray(nodes) ? nodes : slice.call(arguments)
  if (!nodes.length) return null
  else if (nodes.length === 1) return nodes[0]

  var context = nodes[0].context
  var input = context.createGain()
  var output = context.createGain()
  setOutput(input, output)
  nodes.forEach(function (node) {
    if (node.numberOfInputs) input.connect(node)
    node.connect(output)
  })
  var node = lifecycle(input, nodes)
  // fake onended when all onended is called
  var length = node.dependents.length
  function triggerEnded () {
    length--
    if (!length &amp;&amp; node.onended) node.onended()
  }
  node.dependents.forEach(function (node) {
    node.onended = triggerEnded
  })
  return node
}

// TODO: better name
function setOutput (node, output) {
  node.output = node
  node.connect = function (dest) {
    output.connect(dest)
    return node
  }
  return node
}

/**
 * Given a list of nodes, return the ones that are startable
 * @private
 */
function startable (nodes) {
  return nodes.filter(function (dep) {
    return dep &amp;&amp; typeof dep.start === 'function'
  })
}

/**
 * Plug something (a value, a node) into a node parameter
 * @param {String} name - the parameter name
 * @param {AudioNode|Object} value - the value (can be a signal)
 * @param {AudioNode} target - the target audio node
 * @return {AudioNode} the modulator signal if any or undefined
 * @private
 */
export function plug (name, value, node) {
  if (typeof value === 'undefined') {
    // do nothing
  } else if (typeof value.connect === 'function') {
    node[name].value = 0
    value.conn(node[name])
    return value
  } else if (node[name]) {
    node[name].value = value
  }
}

/**
 * Override start and stop functions (if necessary) to handle node dependencies
 * lifecycle.
 * @private
 */
export function lifecycle (node, dependents) {
  node.dependents = startable(dependents)
  if (node.dependents.length) {
    var _start = node.start
    var _stop = node.stop
    node.start = function (time) {
      var res = _start ? _start.call(node, time) : void 0
      node.dependents.forEach(function (d) { if (d.start) d.start(time) })
      if (node.start.then) node.start.then(time, node, dependents)
      return res
    }
    node.stop = function (time) {
      var res = _stop ? _stop.call(node, time) : void 0
      node.dependents.forEach(function (d) { if (d.stop) d.stop(time) })
      return res
    }
  }
  return node
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated at Mon Oct 31 2016 13:30:35 GMT+0100 (CET)
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
