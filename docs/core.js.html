<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core.js - Postman Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#adshr">adshr</a></li><li><a href="global.html#after">after</a></li><li><a href="global.html#bypass">bypass</a></li><li><a href="global.html#connect">connect</a></li><li><a href="global.html#constant">constant</a></li><li><a href="global.html#context">context</a></li><li><a href="global.html#contextOf">contextOf</a></li><li><a href="global.html#dB">dB</a></li><li><a href="global.html#dest">dest</a></li><li><a href="global.html#detune">detune</a></li><li><a href="global.html#feedback">feedback</a></li><li><a href="global.html#fetch">fetch</a></li><li><a href="global.html#filter">filter</a></li><li><a href="global.html#freqEnv">freqEnv</a></li><li><a href="global.html#gain">gain</a></li><li><a href="global.html#gainToDb">gainToDb</a></li><li><a href="global.html#generate">generate</a></li><li><a href="global.html#inst">inst</a></li><li><a href="global.html#lifecycle">lifecycle</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#master">master</a></li><li><a href="global.html#mult">mult</a></li><li><a href="global.html#note">note</a></li><li><a href="global.html#now">now</a></li><li><a href="global.html#osc">osc</a></li><li><a href="global.html#oscBank">oscBank</a></li><li><a href="global.html#perc">perc</a></li><li><a href="global.html#plug">plug</a></li><li><a href="global.html#sample">sample</a></li><li><a href="global.html#samplingRate">samplingRate</a></li><li><a href="global.html#saw">saw</a></li><li><a href="global.html#scale">scale</a></li><li><a href="global.html#seconds">seconds</a></li><li><a href="global.html#signal">signal</a></li><li><a href="global.html#sine">sine</a></li><li><a href="global.html#source">source</a></li><li><a href="global.html#square">square</a></li><li><a href="global.html#tempo">tempo</a></li><li><a href="global.html#triangle">triangle</a></li><li><a href="global.html#when">when</a></li><li><a href="global.html#white">white</a></li><li><a href="global.html#withOptions">withOptions</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">core.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { context } from './context'
import { isNum, lifecycle, plug } from './utils'
var slice = Array.prototype.slice
var isArray = Array.isArray

// ROUTING
// =======
/**
 * Connect nodes in series: A -> B -> C -> D
 * @param {Array&lt;AudioNode>} nodes - the list of nodes to be connected
 * @return {AudioNode} the resulting audio node
 */
export function connect (nodes) {
  nodes = isArray(nodes) ? nodes : slice.call(arguments)
  if (!nodes.length) return null
  else if (nodes.length === 1) return nodes[0]

  var first = nodes[0]
  var last = nodes.reduce(function (src, dest) {
    src.connect(dest)
    return dest
  })
  first.connect = last.connect.bind(last)
  return lifecycle(first, nodes.slice(1))
}

/**
 * Connect nodes in parallel in order to add signals. This is one of the
 * routing functions (the other is `connect`).
 * @param {...AudioNode} nodes - the nodes to be connected
 * @return {AudioNode} the resulting audio node
 * @example
 * add(sine(400), sine(401)).start()
 */
export function add (nodes) {
  nodes = isArray(nodes) ? nodes : slice.call(arguments)
  if (!nodes.length) return null
  else if (nodes.length === 1) return nodes[0]

  var context = nodes[0].context
  var input = context.createGain()
  var output = context.createGain()
  nodes.forEach(function (node) {
    if (node.numberOfInputs) input.connect(node)
    node.connect(output)
  })
  input.connect = output.connect.bind(output)
  return lifecycle(input, nodes)
}

// SIGNALS
// =======

/**
 * Create a constant signal. Normally you will use it in combination with
 * envelopes or modulators.
 *
 * @param {Integer} value - the value of the constant
 * @param {AudioContext} context - (Optional) the audio context
 * @return {AudioNode} the constant audio node
 * @example
 * sine(constant(440)).start()
 */
export function constant (value, ac) {
  // TODO: cache buffer
  var ctx = context(ac)
  var source = ctx.createBufferSource()
  source.loop = true
  source.buffer = ctx.createBuffer(1, 2, ctx.sampleRate)
  var data = source.buffer.getChannelData(0)
  data[0] = data[1] = value
  return source
}

/**
 * Create a signal source. You will use signals to change parameters of a
 * audio node after starting. See example.
 * @param {Integer} value - the value of the constant
 * @param {AudioContext} context - (Optional) the audio context
 * @return {AudioParam} the constant audio node
 * @example
 * var freq = signal(440)
 * sine(freq).start()
 * freq.value.linearRampToValueAtTime(880, after(5))
 */
export function signal (value, ac) {
  var mod = context(ac).createGain()
  mod.gain.value = value
  var signal = connect(constant(1), mod)
  signal.value = mod.gain
  signal.start()
  return signal
}

/**
 * Create a node that bypasses the signal
 * @param {AudioContext} context - (Optional) the audio context
 * @return {AudioNode} the bypass audio node
 * @example
 * connect(sine(300), add(bypass(), dly(0.2)))
 */
export function bypass (ac) {
  return context(ac).createGain()
}

/**
 * Create a gain node
 * @param {Float|AudioNode} gain - the gain value or modulator
 * @param {AudioContext} context - (Optional) the audio context
 * @return {AudioNode} the gain node
 * @example
 * connect(sine(440), gain(0.3))
 * @example
 * // with modulation (kind of tremolo)
 * connect(sine(400), gain(sine(10)))
 */
export function gain (gain, ac) {
  var amp = context(ac).createGain()
  return lifecycle(amp, [
    plug('gain', gain, amp)
  ])
}

/**
 * Multiply a signal.
 * @param {Integer|AudioNode} value - the value
 * @param {AudioNode} signal - the signal to multiply by
 * @example
 * // a vibrato effect
 * sine(440, mult(500, sine(tempo(160))))
 */
export function mult (value, signal) {
  return connect(signal, gain(value))
}

/**
 * Scale a signal. Given a signal (between -1 and 1) scale it to fit in a range.
 * @param {Integer} min - the minimum of the range
 * @param {Integer} max - the minimum of the range
 * @param {AudioNode} signal - the signal to scale
 * @param {AudioContext} context - the optional audio context
 * @return {AudioNode} the scaled signal node
 * @example
 * // create a frequency envelope between 440 and 880 Hz
 * sine(scale(440, 880, adsr(0.1, 0.01, 1, 1)))
 */
export function scale (min, max, source, ctx) {
  if (source.numberOfInputs) source = connect(constant(1, ctx), source)
  var delta = max - min
  return add(constant(min, ctx), mult(delta, source))
}

// OSCILLATORS
// ===========

/**
 * Create an OscillatorNode
 * @param {String} type - one of OscillatorNode [types]()
 * @param {Float|AudioNode} - the frequency (can be a number or a signal)
 * @param {Float|AudioNode} - the detune in cents (can be a number or a signal)
 * @param {AudioContext} context - the optional audio context
 * @return {AudioNode} the oscillator
 * @example
 * osc('sine', 880)
 * osc('sawtooth', 1600, mult(50, sine(5)))
 */
export function osc (type, frequency, detune, ac) {
  var osc = context(ac).createOscillator()
  osc.type = type || 'sine'
  return lifecycle(osc, [
    plug('frequency', frequency, osc),
    plug('detune', detune, osc)
  ])
}
/**
 * Create a sine oscillator. An alias for `osc('sine', ...)`
 * @function
 * @see osc
 * @param {Float|AudioNode} - the frequency (can be a number or a signal)
 * @param {Float|AudioNode} - the detune in cents (can be a number or a signal)
 * @param {AudioContext} context - the optional audio context
 * @return {AudioNode} the oscillator
 * @example
 * sine(1760)
 */
export const sine = osc.bind(null, 'sine')
/**
 * Create a sawtooth oscillator. An alias for `osc('sawtooth', ...)`
 * @function
 * @see osc
 * @param {Float|AudioNode} - the frequency (can be a number or a signal)
 * @param {Float|AudioNode} - the detune in cents (can be a number or a signal)
 * @param {AudioContext} context - the optional audio context
 * @return {AudioNode} the oscillator
 * @example
 * saw(1760)
 */
export const saw = osc.bind(null, 'sawtooth')
/**
 * Create a square oscillator. An alias for `osc('square', ...)`
 * @function
 * @see osc
 * @param {Float|AudioNode} - the frequency (can be a number or a signal)
 * @param {Float|AudioNode} - the detune in cents (can be a number or a signal)
 * @param {AudioContext} context - the optional audio context
 * @return {AudioNode} the oscillator
 * @example
 * square(1760)
 */
export const square = osc.bind(null, 'square')
/**
 * Create a triangle oscillator. An alias for `osc('triangle', ...)`
 * @function
 * @see osc
 * @param {Float|AudioNode} - the frequency (can be a number or a signal)
 * @param {Float|AudioNode} - the detune in cents (can be a number or a signal)
 * @param {AudioContext} context - the optional audio context
 * @return {AudioNode} the oscillator
 * @example
 * triangle(1760)
 */
export const triangle = osc.bind(null, 'triangle')

/**
 * Create an oscillator bank. It returns a signal composed of the sum of the
 * individual oscillators.
 *
 * The idea is provide a collection of frequencies and map them to oscillators.
 * The frequencies can be expressed with an array of frequencies or with a
 * base frequency and an array of relative numbers. Types can be a single value
 * for all oscillators, or a list. Finally an optional list of gains is admitted.
 *
 * @param {Float} base - the base frequency. Can be null
 * @param {Array&lt;Float>} frequencies - an array with the frequencies
 * @param {Array&lt;String>} types - the array of types
 * @param {Array&lt;Number>} gains - the array of gains
 * @param {AudioContext} context - the optional audio context
 * @return {AudioNode}
 *
 * @example
 * // create three sines with unrelated frequencies:
 * oscBank(null, [1345.387, 435.392, 899.432], 'sine')
 * // create three sawtooth with related frequencies:
 * oscBank(440, [ 1, 2, 2.4 ], 'sawtooth')
 * // different types
 * oscBank(null, [400, 600], ['square', 'sawtooth'])
 * // specify gains
 * oscBank(null, [440, 660], 'sine', [0.6, 0.2])
 */
export function oscBank (base, freqs, types, gains, ac) {
  var g, src
  if (!isNum(base)) base = 1
  if (!isArray(freqs)) freqs = [ 1 ]
  if (!isArray(gains)) gains = [ 1 ]
  if (!isArray(types)) types = [ 'sine' ]

  var tl = types.length
  var gl = gains.length
  return connect(add(freqs.map(function (freq, i) {
    src = osc(types[i % tl], base * freq)
    g = gains[i % gl]
    return g === 1 ? src : connect(src, gain(g))
  })), gain(1 / freqs.length))
}

// FILTERS
// =======

/**
 * Create a filter (a [BiquadFilterNode](https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode))
 * @param {String} type - the filter [type](https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode/type)
 * @param {Number|AudioNode} frequency - the frequency in hertzs (can be a number or a signal)
 * @param {Number|AudioNode} Q - the Q of the filter (can be a number or a signal)
 * @param {Number|AudioNode} detune - the detune in cents (can be a number or a signal)
 * @param {AudioContext} context - the optional audio context
 * @return {AudioNode} the filter
 * @example
 * connect(square(800), filter('lowpass', 400))
 */
export function filter (type, frequency, Q, detune, ac) {
  var filter = context(ac).createBiquadFilter()
  filter.type = type
  return lifecycle(filter, [
    plug('frequency', frequency, filter),
    plug('Q', Q, filter),
    plug('detune', detune, filter)
  ])
}
export const lowpass = filter.bind(null, 'lowpass')
export const hipass = filter.bind(null, 'highpass')
export const bandpass = filter.bind(null, 'hipass')

// MODULATORS
// ==========

/**
 * Detune modulator. Can be connected to any `detune` param.
 * Basically is a boilerplate code reductor.
 * @param {Integer} cents - how much
 * @param {Integer|AudioNode} modulator - The modulator. If it's a number,
 * is the frequency of a sine oscillator.
 * @param {AudioContext} context - the optional audio context
 * @example
 * sine(300, detune(200, adshr(0.1, 0.2, 0.5, 1))))
 * sine(300, detune(50, tempo(20)))
 */
export function detune (cents, mod, ac) {
  if (!isNum(cents)) cents = 50
  if (isNum(mod)) mod = sine(mod, ac)
  return mult(cents, mod)
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated at Sat Oct 29 2016 01:50:12 GMT+0200 (CEST)
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
